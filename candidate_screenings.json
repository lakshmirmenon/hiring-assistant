[
  {
    "experience": 3.0,
    "position": "ML engineer",
    "location": "Kochi, Kerala, India",
    "tech_stack": "Python, ML Algorithms",
    "name_hash": "342f5425a78afc1283c6a217f1a81a7dabe163d9101a88fbe31e99949ca2d040",
    "email_hash": "ecf7db9c99a05eb66be0c83d96c12f9926555c782fa4d17ea3c71170ba4caa07",
    "phone_hash": "b6ba97076155b7f2b1ec762e78b76e0431f494b76e7fbd4e16e83197ada770cd",
    "answers": [],
    "completion_status": "completed"
  },
  {
    "experience": 3.0,
    "position": "ML engineer",
    "location": "Kochi, Kerala, India",
    "tech_stack": "Python, ML Algorithms",
    "name_hash": "342f5425a78afc1283c6a217f1a81a7dabe163d9101a88fbe31e99949ca2d040",
    "email_hash": "ecf7db9c99a05eb66be0c83d96c12f9926555c782fa4d17ea3c71170ba4caa07",
    "phone_hash": "b6ba97076155b7f2b1ec762e78b76e0431f494b76e7fbd4e16e83197ada770cd",
    "answers": [],
    "completion_status": "completed"
  },
  {
    "experience": 3.0,
    "position": "ML Engineer",
    "location": "Kochi, Kerala, India",
    "tech_stack": "Python, Machine Learning Algorithms",
    "name_hash": "342f5425a78afc1283c6a217f1a81a7dabe163d9101a88fbe31e99949ca2d040",
    "email_hash": "ecf7db9c99a05eb66be0c83d96c12f9926555c782fa4d17ea3c71170ba4caa07",
    "phone_hash": "ea1c9dc4bf69d337c872f034ef6b386121eb1f91978dae992e27cd74c7bdc8ff",
    "answers": [
      {
        "tech": "Python",
        "question": "**Context Managers and Resource Management:**  \"Write a Python function that reads a large file (e.g., a 1GB file, simulate with a sufficiently large string), processes each line, and writes the processed results to another file.  Ensure your function uses a context manager to handle file I/O and gracefully handles potential exceptions (like `FileNotFoundError` or `IOError`).  Explain why using a context manager is important in this scenario.\"  This tests understanding of `with` statements, exception handling, and efficient file handling.",
        "answer": "I dont know the answer"
      },
      {
        "tech": "Python",
        "question": "**Concurrency with Threading or Multiprocessing:** \"You have a computationally intensive task that involves processing a list of numbers (e.g., calculating the square root of each number).  Write a Python program that uses either threading or multiprocessing to speed up the processing of this list.  Compare and contrast the use of threading versus multiprocessing in this context, discussing their advantages and disadvantages.\" This assesses knowledge of concurrency, understanding of the Global Interpreter Lock (GIL), and the ability to choose the appropriate concurrency model.",
        "answer": "Code Example \u2013 Using multiprocessing for CPU-bound task Since calculating square roots is CPU-bound, multiprocessing will bypass Python\u2019s Global Interpreter Lock (GIL) and actually use multiple CPU cores.  python Copy Edit import math from multiprocessing import Pool, cpu_count  def compute_sqrt(num):     return math.sqrt(num)  if __name__ == \"__main__\":     numbers = list(range(1_000_000))  # Large list     with Pool(cpu_count()) as pool:   # Use all available cores         results = pool.map(compute_sqrt, numbers)     print(f\"Processed {len(results)} numbers.\") 2. Code Example \u2013 Using threading for the same task Threads share the same process memory but still hit the GIL for CPU-bound work, so performance may not improve much here.  python Copy Edit import math from concurrent.futures import ThreadPoolExecutor  def compute_sqrt(num):     return math.sqrt(num)  numbers = list(range(1_000_000))  with ThreadPoolExecutor(max_workers=8) as executor:     results = list(executor.map(compute_sqrt, numbers))  print(f\"Processed {len(results)} numbers.\") 3. Threading vs Multiprocessing for this Scenario Aspect\tThreading\tMultiprocessing GIL Impact\tAffected \u2014 only one thread executes Python bytecode at a time, so CPU-bound tasks see little speedup.\tNot affected \u2014 each process has its own Python interpreter and GIL. Best For\tI/O-bound tasks (network requests, file reads) where threads can run while others wait.\tCPU-bound tasks (math-heavy computations, data processing). Memory Use\tLower \u2014 threads share the same memory space.\tHigher \u2014 processes have separate memory spaces. Overhead\tLow thread start-up cost.\tHigher \u2014 process creation and inter-process communication (IPC) cost. Data Sharing\tEasy \u2014 shared memory.\tHarder \u2014 must use queues, pipes, or shared memory.  \u2705 Conclusion for This Task: Since square root calculation is CPU-bound, multiprocessing is the right choice here \u2014 it avoids the GIL and can fully utilize multiple CPU cores. Threading would be better suited for I/O-heavy workloads like web scraping or file I/O, not pure computation."
      },
      {
        "tech": "Python",
        "question": "**Custom Exception Handling:** \"Design a custom exception class in Python to handle specific errors related to data validation.  For example, create an exception for when a required field is missing or when data is of the wrong type. Show how to use this custom exception in a function that validates user input.\" This evaluates the candidate's grasp of exception handling, object-oriented programming, and the creation of reusable code.",
        "answer": "I am not sure"
      },
      {
        "tech": "Python",
        "question": "**Decorators and Metaprogramming:** \"Write a Python decorator that measures the execution time of a function. The decorator should print the execution time to the console.  Explain how decorators work and why they are useful.\" This tests understanding of decorators, function introspection, and a foundational concept in Python metaprogramming.",
        "answer": "I dont know"
      }
    ],
    "completion_status": "completed"
  },
  {
    "experience": 3.0,
    "position": "ML Engineer",
    "location": "Kochi, Kerala, India",
    "tech_stack": "Python, Machine Learning Algorithms",
    "name_hash": "342f5425a78afc1283c6a217f1a81a7dabe163d9101a88fbe31e99949ca2d040",
    "email_hash": "ecf7db9c99a05eb66be0c83d96c12f9926555c782fa4d17ea3c71170ba4caa07",
    "phone_hash": "ea1c9dc4bf69d337c872f034ef6b386121eb1f91978dae992e27cd74c7bdc8ff",
    "answers": [
      {
        "tech": "Python",
        "question": "**Explain the difference between `is` and `==` in Python, providing examples where they would yield different results.**  (Tests understanding of object identity vs. value equality, a common point of confusion).",
        "answer": "I dont know the answer"
      },
      {
        "tech": "Python",
        "question": "**Write a Python function that takes a list of dictionaries as input, where each dictionary represents a person with 'name' and 'age' keys. The function should return a new list containing only the names of people older than 30, sorted alphabetically.** (Tests list comprehension/manipulation, dictionary access, sorting, and function definition).",
        "answer": "Code Example \u2013 Using multiprocessing for CPU-bound task Since calculating square roots is CPU-bound, multiprocessing will bypass Python\u2019s Global Interpreter Lock (GIL) and actually use multiple CPU cores.  python Copy Edit import math from multiprocessing import Pool, cpu_count  def compute_sqrt(num):     return math.sqrt(num)  if __name__ == \"__main__\":     numbers = list(range(1_000_000))  # Large list     with Pool(cpu_count()) as pool:   # Use all available cores         results = pool.map(compute_sqrt, numbers)     print(f\"Processed {len(results)} numbers.\") 2. Code Example \u2013 Using threading for the same task Threads share the same process memory but still hit the GIL for CPU-bound work, so performance may not improve much here.  python Copy Edit import math from concurrent.futures import ThreadPoolExecutor  def compute_sqrt(num):     return math.sqrt(num)  numbers = list(range(1_000_000))  with ThreadPoolExecutor(max_workers=8) as executor:     results = list(executor.map(compute_sqrt, numbers))  print("
      },
      {
        "tech": "Python",
        "question": "**Describe a scenario where using generators in Python would be beneficial.  Write a simple generator function to illustrate your point.** (Tests understanding of generator functionality, memory efficiency, and lazy evaluation.  Focus is on *when* to use them, not just *how*).",
        "answer": "I am not sure"
      },
      {
        "tech": "Python",
        "question": "**You are given a large text file. Describe how you would efficiently process this file line by line in Python to count the occurrences of a specific word. What considerations would you make for very large files that might not fit entirely into memory?** (Tests knowledge of file I/O, iteration, potentially touching on memory management and the use of generators or iterators for efficient large file processing).",
        "answer": "I dont know"
      },
      {
        "tech": "Machine Learning Algorithms",
        "question": "**Explain the bias-variance tradeoff in the context of model selection.  Give a specific example of a situation where high bias might be preferable to high variance, and explain your reasoning.** (This tests understanding of fundamental ML concepts and their practical implications.)",
        "answer": "The bias-variance tradeoff is about balancing two sources of prediction error in machine learning:  Bias: Error from oversimplifying the model (underfitting). High bias models fail to capture important patterns.  Variance: Error from overfitting to training data. High variance models capture noise and don\u2019t generalize well.  When to Prioritize Reducing Bias Scenario: Your model is systematically wrong even on training data (underfitting).  Example: Predicting house prices using only the number of bedrooms (too simplistic).  Techniques:  Use a more complex model (e.g., upgrade from linear regression to gradient boosting).  Add more relevant features.  Reduce regularization strength.  When to Prioritize Reducing Variance Scenario: Model performs well on training data but poorly on unseen data (overfitting).  Example: A decision tree predicting perfectly on training set but failing on new cases.  Techniques:  Simplify the model (e.g., limit tree depth).  Increase regularization.  Use ensemble methods like baggin"
      },
      {
        "tech": "Machine Learning Algorithms",
        "question": "**You're building a fraud detection system using a logistic regression model.  After training, you find your model has high accuracy but low recall.  Describe three different approaches you could take to improve the recall without significantly sacrificing accuracy.** (This tests problem-solving skills and knowledge of model evaluation metrics and techniques for imbalanced datasets.)",
        "answer": "1. Adjust Class Weights in the Model In logistic regression, you can incorporate class weights to make the model more sensitive to the minority class (fraud cases) by assigning higher penalties for misclassifying them. This is done by setting the class_weight parameter to 'balanced' (which automatically adjusts weights inversely proportional to class frequencies) or manually specifying weights (e.g., higher weight for the fraud class). During training, the loss function will emphasize errors on fraud instances more, encouraging the model to identify more true positives. This improves recall by reducing false negatives without overfitting to the majority class, and since the dataset imbalance is addressed directly, accuracy often remains stable or decreases only slightly as the model still correctly classifies most non-fraud cases. 2. Apply Oversampling to the Minority Class Use techniques like Synthetic Minority Over-sampling Technique (SMOTE) to generate synthetic examples of the fraud class, balancing the training dataset before fitting the logistic regression model. This increases the representation of fraud cases, allowing the model to learn better patterns for detecting them, thereby boosting recall by capturing more true positives. To avoid significantly sacrificing accuracy, apply oversampling only to the training set (not validation/test) and combine it with cross-validation to prevent overfitting; the model's performance on the majority class typically stays strong, leading to minimal accuracy loss while improving overall balance."
      },
      {
        "tech": "Machine Learning Algorithms",
        "question": "**Compare and contrast the strengths and weaknesses of Random Forests and Gradient Boosting Machines (GBMs) for a regression task. When would you choose one over the other?** (This tests understanding of different algorithm types and their suitability for specific tasks.)",
        "answer": "I am not sure"
      },
      {
        "tech": "Machine Learning Algorithms",
        "question": "**Describe how you would approach handling missing data in a dataset you're using to train a machine learning model.  Consider different scenarios, such as missing completely at random (MCAR), missing at random (MAR), and missing not at random (MNAR).** (This tests practical knowledge of data preprocessing and the importance of handling missing data appropriately.)",
        "answer": "I dont know"
      }
    ],
    "completion_status": "completed"
  },
  {
    "experience": 3.0,
    "position": "Full Stack Developer",
    "location": "Kochi, Kerala, India",
    "tech_stack": "Javascript, React",
    "name_hash": "56511fafa9d63d3d8e37c41776d4af39809074fdce883e514d0b183f12fae3ea",
    "email_hash": "61c4a6d03e907f008884b2ab9ec3f71769115526dee34919345c1bf74edb8496",
    "phone_hash": "ea1c9dc4bf69d337c872f034ef6b386121eb1f91978dae992e27cd74c7bdc8ff",
    "answers": [
      {
        "tech": "Javascript",
        "question": "You are tasked with building a feature that allows users to upload images to a website.  Describe how you would handle potential errors during the upload process, such as network issues or invalid file types, and how you would provide informative feedback to the user.  Consider both client-side and (briefly) server-side considerations.",
        "answer": "Code Example \u2013 Using multiprocessing for CPU-bound task Since calculating square roots is CPU-bound, multiprocessing will bypass Python\u2019s Global Interpreter Lock (GIL) and actually use multiple CPU cores.  python Copy Edit import math from multiprocessing import Pool, cpu_count  def compute_sqrt(num):     return math.sqrt(num)  if __name__ == \"__main__\":     numbers = list(range(1_000_000))  # Large list     with Pool(cpu_count()) as pool:   # Use all available cores         results = pool.map(compute_sqrt, numbers)     print(f\"Processed {len(results)} numbers.\") 2. Code Example \u2013 Using threading for the same task Threads share the same process memory but still hit the GIL for CPU-bound work, so performance may not improve much here.  python Copy Edit import math from concurrent.futures import ThreadPoolExecutor  def compute_sqrt(num):     return math.sqrt(num)  numbers = list(range(1_000_000))  with ThreadPoolExecutor(max_workers=8) as executor:     results = list(executor.map(compute_sqrt, numbers))  print("
      }
    ],
    "completion_status": "completed"
  }
]